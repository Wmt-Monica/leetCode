<application>
  <component name="AppStorage">
    <histories>
      <item value="寻找中间" />
      <item value="合并有序链表" />
      <item value="有序" />
      <item value="标记" />
      <item value="判断" />
      <item value="检测环" />
      <item value="哨兵" />
      <item value="尾插法" />
      <item value="w尾插法" />
      <item value="头插法反转" />
      <item value="反转" />
      <item value="遍历" />
      <item value="头插法" />
      <item value="尾部" />
      <item value="辅助指针" />
      <item value="辅助" />
      <item value="存在" />
      <item value="缓存" />
      <item value="Raw use of parameterized class 'Node'" />
      <item value="判断奇偶数" />
      <item value="慢" />
      <item value="快" />
      <item value="块" />
      <item value="查找前驱节点" />
      <item value="回文" />
      <item value="hu" />
      <item value="链表" />
      <item value="Google" />
      <item value="数据结构与算法之美" />
      <item value="数据结构预算法之美" />
      <item value="s unrecognized or represents more than one time zone. " />
      <item value="java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support." />
      <item value="Current request is not a multipart request" />
      <item value=" Return the {@link AutoConfigurationEntry} based on the {@link AnnotationMetadata} &#9; * of the importing {@link Configuration @Configuration} class. &#9; * @param annotationMetadata the annotation metadata of the configuration class &#9; * @return the auto-configurations that should be imported &#9; */" />
      <item value="/** &#9; * Return the {@link AutoConfigurationEntry} based on the {@link AnnotationMetadata} &#9; * of the importing {@link Configuration @Configuration} class. &#9; * @param annotationMetadata the annotation metadata of the configuration class &#9; * @return the auto-configurations that should be imported &#9; */" />
      <item value=" * {@link DeferredImportSelector} to handle {@link EnableAutoConfiguration  * auto-configuration}. This class can also be subclassed if a custom variant of  * {@link EnableAutoConfiguration @EnableAutoConfiguration} is needed." />
      <item value="实体" />
      <item value="自定义对象" />
      <item value="参数" />
      <item value="提交方式" />
      <item value="/*  * Copyright 2002-2019 the original author or authors.  *  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      https://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.springframework.context.annotation;  import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.annotation.AliasFor; import org.springframework.stereotype.Component;  /**  * Indicates that a class declares one or more {@link Bean @Bean} methods and  * may be processed by the Spring container to generate bean definitions and  * service requests for those beans at runtime, for example:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * public class AppConfig {  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         // instantiate, configure and return bean ...  *     }  * }&lt;/pre&gt;  *  * &lt;h2&gt;Bootstrapping {@code @Configuration} classes&lt;/h2&gt;  *  * &lt;h3&gt;Via {@code AnnotationConfigApplicationContext}&lt;/h3&gt;  *  * &lt;p&gt;{@code @Configuration} classes are typically bootstrapped using either  * {@link AnnotationConfigApplicationContext} or its web-capable variant,  * {@link org.springframework.web.context.support.AnnotationConfigWebApplicationContext  * AnnotationConfigWebApplicationContext}. A simple example with the former follows:  *  * &lt;pre class=&quot;code&quot;&gt;  * AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();  * ctx.register(AppConfig.class);  * ctx.refresh();  * MyBean myBean = ctx.getBean(MyBean.class);  * // use myBean ...  * &lt;/pre&gt;  *  * &lt;p&gt;See the {@link AnnotationConfigApplicationContext} javadocs for further details, and see  * {@link org.springframework.web.context.support.AnnotationConfigWebApplicationContext  * AnnotationConfigWebApplicationContext} for web configuration instructions in a  * {@code Servlet} container.  *  * &lt;h3&gt;Via Spring {@code &lt;beans&gt;} XML&lt;/h3&gt;  *  * &lt;p&gt;As an alternative to registering {@code @Configuration} classes directly against an  * {@code AnnotationConfigApplicationContext}, {@code @Configuration} classes may be  * declared as normal {@code &lt;bean&gt;} definitions within Spring XML files:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;lt;beans&amp;gt;  *    &amp;lt;context:annotation-config/&amp;gt;  *    &amp;lt;bean class=&quot;com.acme.AppConfig&quot;/&amp;gt;  * &amp;lt;/beans&amp;gt;  * &lt;/pre&gt;  *  * &lt;p&gt;In the example above, {@code &lt;context:annotation-config/&gt;} is required in order to  * enable {@link ConfigurationClassPostProcessor} and other annotation-related  * post processors that facilitate handling {@code @Configuration} classes.  *  * &lt;h3&gt;Via component scanning&lt;/h3&gt;  *  * &lt;p&gt;{@code @Configuration} is meta-annotated with {@link Component @Component}, therefore  * {@code @Configuration} classes are candidates for component scanning (typically using  * Spring XML's {@code &lt;context:component-scan/&gt;} element) and therefore may also take  * advantage of {@link Autowired @Autowired}/{@link javax.inject.Inject @Inject}  * like any regular {@code @Component}. In particular, if a single constructor is present  * autowiring semantics will be applied transparently for that constructor:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * public class AppConfig {  *  *     private final SomeBean someBean;  *  *     public AppConfig(SomeBean someBean) {  *         this.someBean = someBean;  *     }  *  *     // &amp;#064;Bean definition using &quot;SomeBean&quot;  *  * }&lt;/pre&gt;  *  * &lt;p&gt;{@code @Configuration} classes may not only be bootstrapped using  * component scanning, but may also themselves &lt;em&gt;configure&lt;/em&gt; component scanning using  * the {@link ComponentScan @ComponentScan} annotation:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * &amp;#064;ComponentScan(&quot;com.acme.app.services&quot;)  * public class AppConfig {  *     // various &amp;#064;Bean definitions ...  * }&lt;/pre&gt;  *  * &lt;p&gt;See the {@link ComponentScan @ComponentScan} javadocs for details.  *  * &lt;h2&gt;Working with externalized values&lt;/h2&gt;  *  * &lt;h3&gt;Using the {@code Environment} API&lt;/h3&gt;  *  * &lt;p&gt;Externalized values may be looked up by injecting the Spring  * {@link org.springframework.core.env.Environment} into a {@code @Configuration}  * class &amp;mdash; for example, using the {@code @Autowired} annotation:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * public class AppConfig {  *  *     &amp;#064Autowired Environment env;  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         MyBean myBean = new MyBean();  *         myBean.setName(env.getProperty(&quot;bean.name&quot;));  *         return myBean;  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;Properties resolved through the {@code Environment} reside in one or more &quot;property  * source&quot; objects, and {@code @Configuration} classes may contribute property sources to  * the {@code Environment} object using the {@link PropertySource @PropertySource}  * annotation:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * &amp;#064;PropertySource(&quot;classpath:/com/acme/app.properties&quot;)  * public class AppConfig {  *  *     &amp;#064Inject Environment env;  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         return new MyBean(env.getProperty(&quot;bean.name&quot;));  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;See the {@link org.springframework.core.env.Environment Environment}  * and {@link PropertySource @PropertySource} javadocs for further details.  *  * &lt;h3&gt;Using the {@code @Value} annotation&lt;/h3&gt;  *  * &lt;p&gt;Externalized values may be injected into {@code @Configuration} classes using  * the {@link Value @Value} annotation:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * &amp;#064;PropertySource(&quot;classpath:/com/acme/app.properties&quot;)  * public class AppConfig {  *  *     &amp;#064Value(&quot;${bean.name}&quot;) String beanName;  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         return new MyBean(beanName);  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;This approach is often used in conjunction with Spring's  * {@link org.springframework.context.support.PropertySourcesPlaceholderConfigurer  * PropertySourcesPlaceholderConfigurer} that can be enabled &lt;em&gt;automatically&lt;/em&gt;  * in XML configuration via {@code &lt;context:property-placeholder/&gt;} or &lt;em&gt;explicitly&lt;/em&gt;  * in a {@code @Configuration} class via a dedicated {@code static} {@code @Bean} method  * (see &quot;a note on BeanFactoryPostProcessor-returning {@code @Bean} methods&quot; of  * {@link Bean @Bean}'s javadocs for details). Note, however, that explicit registration  * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}  * method is typically only required if you need to customize configuration such as the  * placeholder syntax, etc. Specifically, if no bean post-processor (such as a  * {@code PropertySourcesPlaceholderConfigurer}) has registered an &lt;em&gt;embedded value  * resolver&lt;/em&gt; for the {@code ApplicationContext}, Spring will register a default  * &lt;em&gt;embedded value resolver&lt;/em&gt; which resolves placeholders against property sources  * registered in the {@code Environment}. See the section below on composing  * {@code @Configuration} classes with Spring XML using {@code @ImportResource}; see  * the {@link Value @Value} javadocs; and see the {@link Bean @Bean} javadocs for details  * on working with {@code BeanFactoryPostProcessor} types such as  * {@code PropertySourcesPlaceholderConfigurer}.  *  * &lt;h2&gt;Composing {@code @Configuration} classes&lt;/h2&gt;  *  * &lt;h3&gt;With the {@code @Import} annotation&lt;/h3&gt;  *  * &lt;p&gt;{@code @Configuration} classes may be composed using the {@link Import @Import} annotation,  * similar to the way that {@code &lt;import&gt;} works in Spring XML. Because  * {@code @Configuration} objects are managed as Spring beans within the container,  * imported configurations may be injected &amp;mdash; for example, via constructor injection:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * public class DatabaseConfig {  *  *     &amp;#064;Bean  *     public DataSource dataSource() {  *         // instantiate, configure and return DataSource  *     }  * }  *  * &amp;#064;Configuration  * &amp;#064;Import(DatabaseConfig.class)  * public class AppConfig {  *  *     private final DatabaseConfig dataConfig;  *  *     public AppConfig(DatabaseConfig dataConfig) {  *         this.dataConfig = dataConfig;  *     }  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         // reference the dataSource() bean method  *         return new MyBean(dataConfig.dataSource());  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;Now both {@code AppConfig} and the imported {@code DatabaseConfig} can be bootstrapped  * by registering only {@code AppConfig} against the Spring context:  *  * &lt;pre class=&quot;code&quot;&gt;  * new AnnotationConfigApplicationContext(AppConfig.class);&lt;/pre&gt;  *  * &lt;h3&gt;With the {@code @Profile} annotation&lt;/h3&gt;  *  * &lt;p&gt;{@code @Configuration} classes may be marked with the {@link Profile @Profile} annotation to  * indicate they should be processed only if a given profile or profiles are &lt;em&gt;active&lt;/em&gt;:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Profile(&quot;development&quot;)  * &amp;#064;Configuration  * public class EmbeddedDatabaseConfig {  *  *     &amp;#064;Bean  *     public DataSource dataSource() {  *         // instantiate, configure and return embedded DataSource  *     }  * }  *  * &amp;#064;Profile(&quot;production&quot;)  * &amp;#064;Configuration  * public class ProductionDatabaseConfig {  *  *     &amp;#064;Bean  *     public DataSource dataSource() {  *         // instantiate, configure and return production DataSource  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;Alternatively, you may also declare profile conditions at the {@code @Bean} method level  * &amp;mdash; for example, for alternative bean variants within the same configuration class:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * public class ProfileDatabaseConfig {  *  *     &amp;#064;Bean(&quot;dataSource&quot;)  *     &amp;#064;Profile(&quot;development&quot;)  *     public DataSource embeddedDatabase() { ... }  *  *     &amp;#064;Bean(&quot;dataSource&quot;)  *     &amp;#064;Profile(&quot;production&quot;)  *     public DataSource productionDatabase() { ... }  * }&lt;/pre&gt;  *  * &lt;p&gt;See the {@link Profile @Profile} and {@link org.springframework.core.env.Environment}  * javadocs for further details.  *  * &lt;h3&gt;With Spring XML using the {@code @ImportResource} annotation&lt;/h3&gt;  *  * &lt;p&gt;As mentioned above, {@code @Configuration} classes may be declared as regular Spring  * {@code &lt;bean&gt;} definitions within Spring XML files. It is also possible to  * import Spring XML configuration files into {@code @Configuration} classes using  * the {@link ImportResource @ImportResource} annotation. Bean definitions imported from  * XML can be injected &amp;mdash; for example, using the {@code @Inject} annotation:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * &amp;#064;ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)  * public class AppConfig {  *  *     &amp;#064Inject DataSource dataSource; // from XML  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         // inject the XML-defined dataSource bean  *         return new MyBean(this.dataSource);  *     }  * }&lt;/pre&gt;  *  * &lt;h3&gt;With nested {@code @Configuration} classes&lt;/h3&gt;  *  * &lt;p&gt;{@code @Configuration} classes may be nested within one another as follows:  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;Configuration  * public class AppConfig {  *  *     &amp;#064;Inject DataSource dataSource;  *  *     &amp;#064;Bean  *     public MyBean myBean() {  *         return new MyBean(dataSource);  *     }  *  *     &amp;#064;Configuration  *     static class DatabaseConfig {  *         &amp;#064;Bean  *         DataSource dataSource() {  *             return new EmbeddedDatabaseBuilder().build();  *         }  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;When bootstrapping such an arrangement, only {@code AppConfig} need be registered  * against the application context. By virtue of being a nested {@code @Configuration}  * class, {@code DatabaseConfig} &lt;em&gt;will be registered automatically&lt;/em&gt;. This avoids  * the need to use an {@code @Import} annotation when the relationship between  * {@code AppConfig} and {@code DatabaseConfig} is already implicitly clear.  *  * &lt;p&gt;Note also that nested {@code @Configuration} classes can be used to good effect  * with the {@code @Profile} annotation to provide two options of the same bean to the  * enclosing {@code @Configuration} class.  *  * &lt;h2&gt;Configuring lazy initialization&lt;/h2&gt;  *  * &lt;p&gt;By default, {@code @Bean} methods will be &lt;em&gt;eagerly instantiated&lt;/em&gt; at container  * bootstrap time.  To avoid this, {@code @Configuration} may be used in conjunction with  * the {@link Lazy @Lazy} annotation to indicate that all {@code @Bean} methods declared  * within the class are by default lazily initialized. Note that {@code @Lazy} may be used  * on individual {@code @Bean} methods as well.  *  * &lt;h2&gt;Testing support for {@code @Configuration} classes&lt;/h2&gt;  *  * &lt;p&gt;The Spring &lt;em&gt;TestContext framework&lt;/em&gt; available in the {@code spring-test} module  * provides the {@code @ContextConfiguration} annotation which can accept an array of  * &lt;em&gt;component class&lt;/em&gt; references &amp;mdash; typically {@code @Configuration} or  * {@code @Component} classes.  *  * &lt;pre class=&quot;code&quot;&gt;  * &amp;#064;RunWith(SpringRunner.class)  * &amp;#064;ContextConfiguration(classes = {AppConfig.class, DatabaseConfig.class})  * public class MyTests {  *  *     &amp;#064;Autowired MyBean myBean;  *  *     &amp;#064;Autowired DataSource dataSource;  *  *     &amp;#064;Test  *     public void test() {  *         // assertions against myBean ...  *     }  * }&lt;/pre&gt;  *  * &lt;p&gt;See the  * &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-framework&quot;&gt;TestContext framework&lt;/a&gt;  * reference documentation for details.  *  * &lt;h2&gt;Enabling built-in Spring features using {@code @Enable} annotations&lt;/h2&gt;  *  * &lt;p&gt;Spring features such as asynchronous method execution, scheduled task execution,  * annotation driven transaction management, and even Spring MVC can be enabled and  * configured from {@code @Configuration} classes using their respective &quot;{@code @Enable}&quot;  * annotations. See  * {@link org.springframework.scheduling.annotation.EnableAsync @EnableAsync},  * {@link org.springframework.scheduling.annotation.EnableScheduling @EnableScheduling},  * {@link org.springframework.transaction.annotation.EnableTransactionManagement @EnableTransactionManagement},  * {@link org.springframework.context.annotation.EnableAspectJAutoProxy @EnableAspectJAutoProxy},  * and {@link org.springframework.web.servlet.config.annotation.EnableWebMvc @EnableWebMvc}  * for details.  *  * &lt;h2&gt;Constraints when authoring {@code @Configuration} classes&lt;/h2&gt;  *  * &lt;ul&gt;  * &lt;li&gt;Configuration classes must be provided as classes (i.e. not as instances returned  * from factory methods), allowing for runtime enhancements through a generated subclass.  * &lt;li&gt;Configuration classes must be non-final (allowing for subclasses at runtime),  * unless the {@link #proxyBeanMethods() proxyBeanMethods} flag is set to {@code false}  * in which case no runtime-generated subclass is necessary.  * &lt;li&gt;Configuration classes must be non-local (i.e. may not be declared within a method).  * &lt;li&gt;Any nested configuration classes must be declared as {@code static}.  * &lt;li&gt;{@code @Bean} methods may not in turn create further configuration classes  * (any such instances will be treated as regular beans, with their configuration  * annotations remaining undetected).  * &lt;/ul&gt;  *  * @author Rod Johnson  * @author Chris Beams  * @author Juergen Hoeller  * @since 3.0  * @see Bean  * @see Profile  * @see Import  * @see ImportResource  * @see ComponentScan  * @see Lazy  * @see PropertySource  * @see AnnotationConfigApplicationContext  * @see ConfigurationClassPostProcessor  * @see org.springframework.core.env.Environment  * @see org.springframework.test.context.ContextConfiguration  */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Configuration {  &#9;/** &#9; * Explicitly specify the name of the Spring bean definition associated with the &#9; * {@code @Configuration} class. If left unspecified (the common case), a bean &#9; * name will be automatically generated. &#9; * &lt;p&gt;The custom name applies only if the {@code @Configuration} class is picked &#9; * up via component scanning or supplied directly to an &#9; * {@link AnnotationConfigApplicationContext}. If the {@code @Configuration} class &#9; * is registered as a traditional XML bean definition, the name/id of the bean &#9; * element will take precedence. &#9; * @return the explicit component name, if any (or empty String otherwise) &#9; * @see AnnotationBeanNameGenerator &#9; */ &#9;@AliasFor(annotation = Component.class) &#9;String value() default &quot;&quot;;  &#9;/** &#9; * Specify whether {@code @Bean} methods should get proxied in order to enforce &#9; * bean lifecycle behavior, e.g. to return shared singleton bean instances even &#9; * in case of direct {@code @Bean} method calls in user code. This feature &#9; * requires method interception, implemented through a runtime-generated CGLIB &#9; * subclass which comes with limitations such as the configuration class and &#9; * its methods not being allowed to declare {@code final}. &#9; * &lt;p&gt;The default is {@code true}, allowing for 'inter-bean references' within &#9; * the configuration class as well as for external calls to this configuration's &#9; * {@code @Bean} methods, e.g. from another configuration class. If this is not &#9; * needed since each of this particular configuration's {@code @Bean} methods &#9; * is self-contained and designed as a plain factory method for container use, &#9; * switch this flag to {@code false} in order to avoid CGLIB subclass processing. &#9; * &lt;p&gt;Turning off bean method interception effectively processes {@code @Bean} &#9; * methods individually like when declared on non-{@code @Configuration} classes, &#9; * a.k.a. &quot;@Bean Lite Mode&quot; (see {@link Bean @Bean's javadoc}). It is therefore &#9; * behaviorally equivalent to removing the {@code @Configuration} stereotype. &#9; * @since 5.2 &#9; */ &#9;boolean proxyBeanMethods() default true;  } " />
      <item value="目标类" />
      <item value="销毁" />
      <item value="Indicates that a component is eligible for registration when one or more  * {@linkplain #value specified profiles} are active.  *  * &lt;p&gt;A &lt;em&gt;profile&lt;/em&gt; is a named logical grouping that may be activated  * programmatically via {@link ConfigurableEnvironment#setActiveProfiles} or declaratively  * by setting the {@link AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME  * spring.profiles.active} property as a JVM system property, as an  * environment variable, or as a Servlet context parameter in {@code web.xml}  * for web applications. Profiles may also be activated declaratively in  * integration tests via the {@code @ActiveProfiles} annotation.  *  * &lt;p&gt;The {@code @Profile} annotation may be used in any of the following ways:  * &lt;ul&gt;  * &lt;li&gt;as a type-level annotation on any class directly or indirectly annotated with  * {@code @Component}, including {@link Configuration @Configuration} classes&lt;/li&gt;  * &lt;li&gt;as a meta-annotation, for the purpose of composing custom stereotype annotations&lt;/li&gt;  * &lt;li&gt;as a method-level annotation on any {@link Bean @Bean} method&lt;/li&gt;  * &lt;/ul&gt;  *  * &lt;p&gt;If a {@code @Configuration} class is marked with {@code @Profile}, all of the  * {@code @Bean} methods and {@link Import @Import} annotations associated with that class  * will be bypassed unless one or more of the specified profiles are active. A profile  * string may contain a simple profile name (for example {@code &quot;p1&quot;}) or a profile  * expression. A profile expression allows for more complicated profile logic to be  * expressed, for example {@code &quot;p1 &amp; p2&quot;}. See {@link Profiles#of(String...)} for more  * details about supported formats.  *  * &lt;p&gt;This is analogous to the behavior in Spring XML: if the {@code profile} attribute of  * the {@code beans} element is supplied e.g., {@code &lt;beans profile=&quot;p1,p2&quot;&gt;}, the  * {@code beans} element will not be parsed unless at least profile 'p1' or 'p2' has been  * activated. Likewise, if a {@code @Component} or {@code @Configuration} class is marked  * with {@code @Profile({&quot;p1&quot;, &quot;p2&quot;})}, that class will not be registered or processed unless  * at least profile 'p1' or 'p2' has been activated.  *  * &lt;p&gt;If a given profile is prefixed with the NOT operator ({@code !}), the annotated  * component will be registered if the profile is &lt;em&gt;not&lt;/em&gt; active &amp;mdash; for example,  * given {@code @Profile({&quot;p1&quot;, &quot;!p2&quot;})}, registration will occur if profile 'p1' is active  * or if profile 'p2' is &lt;em&gt;not&lt;/em&gt; active.  *  * &lt;p&gt;If the {@code @Profile} annotation is omitted, registration will occur regardless  * of which (if any) profiles are active.  *  * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; With {@code @Profile} on {@code @Bean} methods, a special scenario may  * apply: In the case of overloaded {@code @Bean} methods of the same Java method name  * (analogous to constructor overloading), an {@code @Profile} condition needs to be  * consistently declared on all overloaded methods. If the conditions are inconsistent,  * only the condition on the first declaration among the overloaded methods will matter.  * {@code @Profile} can therefore not be used to select an overloaded method with a  * particular argument signature over another; resolution between all factory methods  * for the same bean follows Spring's constructor resolution algorithm at creation time.  * &lt;b&gt;Use distinct Java method names pointing to the same {@link Bean#name bean name}  * if you'd like to define alternative beans with different profile conditions&lt;/b&gt;;  * see {@code ProfileDatabaseConfig} in {@link Configuration @Configuration}'s javadoc.  *  * &lt;p&gt;When defining Spring beans via XML, the {@code &quot;profile&quot;} attribute of the  * {@code &lt;beans&gt;} element may be used. See the documentation in the  * {@code spring-beans} XSD (version 3.1 or greater) for details." />
      <item value="资源" />
      <item value="productCategory" />
      <item value="productCategoryId" />
      <item value="/**  * This interface represents the abstract notion of a principal, which  * can be used to represent any entity, such as an individual, a  * corporation, and a login id.  *  * @see java.security.cert.X509Certificate  *  * @author Li Gong  * @since 1.1" />
      <item value="Error resolving template [my/encode/12345], template might not exist or might not be accessible by any of the configured Template Resolvers" />
      <item value="Hex-encoded string must have an even number of characters" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="50" />
        <entry key="ENGLISH" value="51" />
        <entry key="CATALAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>